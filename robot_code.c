#pragma config(Sensor, S1,     sensorF,             sensorReflection)
#pragma config(Sensor, S2,     sensorR,             sensorReflection)
#pragma config(Sensor, S3,     sensorRR,             sensorReflection)
#pragma config(Motor,  motorA,          motorL,        tmotorNormal, openLoop)
#pragma config(Motor,  motorB,          motorGripper,  tmotorNormal, openLoop)
#pragma config(Motor,  motorC,          motorR,        tmotorNormal, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

// The high level overview of the line following method is:
// - The robot follows the edge of the tape, referred to as the line.
// - If the right sensor detects white it will turn right to get back on the line.
// - If the right sensor detects black it will turn left to get back on the line.

// A PD controller is used to try to keep the sensor value at the value between black and white.
// ex. The right sensor value is 50, the value between black and white is 45.
// Darker values are lower, so the robot is closer to white, we expect it to turn right to get back on the line.
// proportionalError = 50(sensor value) - 45(target sensor value) = 5;
// control = proportionalError*kP
// The motors are then set, leftMotor =  defaultSpeed + control, rightMotor = defaultSpeed - control
// As you can see the leftMotor value will be higher in this instance, so the robot will turn right as expected.
// The speed of this turn will be determined by how large the error is and the value of kP.
// The derivative controller does something similar, but is harder to explain, wiki it.

// - If the front sensor detects black it will turn 90 degrees left.

//Sensor value variables to avoid excessive calls of SensorValue.
//Front sensor.
int svF;
//Right sensor for line following.
int svR;
//Further right sensor. Blue is detected when both right sensors are within error value of blue.
int svRR;

//PID controller struct.
//PID can be looked up on wikipedia.
typedef struct
{
	int target;//Target value.
	int eP;//Proportional error.
	int eI;//Integral Error. Not used in this program.
	int ePPrevious;//Previous proportional error, used for derivative error calculation.
	int eD;//Derivative error.
	float kP;//Proportional control constant.
	float kI;//Integral control constant.
	float kD;//Derivative control constant.
	float control;//Output of the PID.
} PidController;

//Line follower PID.
PidController pidFollow;

//Measured colors, can be updated for different tapes or lighting conditions.
const int cBlack = 37;
const int cWhite = 56;
const int cBlue = 50;

const int cBlackThreshold = cBlack + 0.5*(cWhite-cBlack); //Will be used to determine if front sensor is on black.
const int cTargetBlack = cBlack + 0.5*(cWhite-cBlack); //Target color for following the edge of the black tape. The value between white and black.

//Track progress through track.
bool halfComplete = false;
bool complete = false;

//Sensing blue
const int cBlueError = 2;//Acceptable error from measured blue value.
//Sensing blue timing
int timeLastBlue = 0;
int timeSinceLastBlue = 0;
const int timeSinceLastBlueMin = 2 * 1000; //ms

const int speed = 100; //Speed Range: 0..100
//Function simplifies setting motor speeds, takes a range of -1..1
void setMotors(float motorSpeedL, float motorSpeedR)
{
	motor[motorL] = (motorSpeedL * speed);
	motor[motorR] = (motorSpeedR * speed);
}

float turnWait;//Wait during 90 degree turn.
float turnPauses;//Pause before and after turn to reduce momentum build up.
void turn()
{
	setMotors(0,0);
	wait1Msec(turnPauses*(float)1000);

	//Opposite speeds for a left turn.
	setMotors(-100,100);
	wait1Msec(turnWait*(float)1000.0);

	setMotors(0,0);
	wait1Msec(turnPauses*(float)1000);
}

//Absolute value function.
int abs(int x)
{
	return (x>0) ? (x) : -(x);
}

task main()
{
	//Brake motors when speed is set to zero.
	bFloatDuringInactiveMotorPWM = false;

	//With a speed of 1.0 one of the motors will always be at 100 power.
	float pidSpeed = 1; //The default speed. The control will be added or subtracted from this.
	if (pidSpeed == 0.5)
	{
		//PID tuning for speed of 0.5
		pidFollow.kP = 0.05;
		pidFollow.kD = 0.17;
	}
	else if (pidSpeed == 1.0)
	{
		//PID tuning for speed of 1.0
		pidFollow.kP = 1.2 * 0.05;
		pidFollow.kD = 1.6 * 0.17;
	}

	//Default turning times.
	//Wait time during a 90 degree turn.
	turnWait = 0.26;
	//Pauses occur before and after turning to prevent momentum build up.
	turnPauses = 0.01;

	//Dual motors with gear ratio 42:24
	bool dualMotors_42_24 = true;
	if (dualMotors_42_24)
	{
		//Reduced time and increased delay for higher speed.
		turnWait = 0.25;
		turnPauses = 0.04;
		//Tuning
		pidFollow.kP *= 1.4;
		pidFollow.kD *= 1.8;
	}

	pidFollow.target = cTargetBlack; //Follow this colour.
	pidFollow.ePPrevious = 0; //Initialise previous error to 0.

	//Main Loop
	while (true)
	{
		//Set sensor value variables to avoid overhead of calling SensorValue() function multiple times.
		svR = SensorValue(sensorR);
		svF = SensorValue(sensorF);
		svRR = SensorValue(sensorRR);

		//PID Controller error values.
		pidFollow.eP = svR - pidFollow.target;
		pidFollow.eD = pidFollow.eP - pidFollow.ePPrevious;
		pidFollow.ePPrevious = pidFollow.eP;

		//Control of PID is the error values multiplied by the control constants that have been tuned for the problem.
		//Set the motors to the default speed +- the control. This will turn the robot to correct for errors.
		pidFollow.control = pidFollow.kP*(float)pidFollow.eP + pidFollow.kD*(float)pidFollow.eD;
		setMotors(pidSpeed+pidFollow.control, pidSpeed-pidFollow.control);

		if (svF < cBlackThreshold)
		{
			//Front sensor has been hit. Turn 90 degrees left.
			turn();
		}

		//Blue should not be sensed many times in a row.
		//Time since last detection of blue must be at least a certain amount.
		if (timeSinceLastBlue >= timeSinceLastBlueMin)
		{
			//Both right sensors are within acceptable error of blue value. 
			//This will detect blue quickly with a very low chance of false positives considering the configuration.
			if ((abs(svR-cBlue) <= cBlueError) && (abs(svRR-cBlue) <= cBlueError) )
			{
					//Hit blue.

					//Set the times to zero.
					timeLastBlue = nSysTime;
					timeSinceLastBlue = 0;

					if (!halfComplete)
					{
						//Completed the first half of the track.
						halfComplete = true;

						//Stop while playing.
						setMotors(0,0);

						//Play beeps.
						PlayTone(1000,10);
						wait1Msec(20);
						PlayTone(1000,10);
						wait1Msec(20);
						PlayTone(1000,10);
					}
					else if (!complete)
					{
						//Completed the track. Stop and break main loop. Ending program.
						complete = true;
						setMotors(0,0);
						break;
					}
			}
		}
		else
		{
			//Update counter for time since last detection of blue.
			timeSinceLastBlue = nSysTime - timeLastBlue;
		}

		//End main loop.
	}

	//End program.
}
